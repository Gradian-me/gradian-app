/**
 * AI Builder Wrapper Component
 * Reusable wrapper for AI builder functionality that can be used in pages or dialogs
 */

'use client';

import { Skeleton } from '@/components/ui/skeleton';
import {
  AiBuilderForm,
  AiBuilderResponse,
  MessageDisplay,
  useAiAgents,
  useAiBuilder,
} from '@/domains/ai-builder';
import type { AiAgent, AnnotationItem, SchemaAnnotation } from '@/domains/ai-builder/types';
import { Modal } from '@/gradian-ui/data-display/components/Modal';
import { SchemaFormWrapper } from '@/gradian-ui/form-builder/components/FormLifecycleManager';
import { ListInput } from '@/gradian-ui/form-builder/form-elements';
import { ConfirmationMessage } from '@/gradian-ui/form-builder/form-elements/components/ConfirmationMessage';
import type { FormSchema } from '@/gradian-ui/schema-manager/types/form-schema';
import { DEMO_MODE } from '@/gradian-ui/shared/constants/application-variables';
import { AnimatePresence, motion } from 'framer-motion';
import { useCallback, useEffect, useRef, useState } from 'react';
import { AiBuilderLoadingIndicator } from './AiBuilderLoadingIndicator';
import { extractParametersBySectionId } from '../utils/ai-shared-utils';

export interface AiBuilderWrapperProps {
  initialAgentId?: string;
  initialUserPrompt?: string;
  onClose?: () => void;
  mode?: 'page' | 'dialog';
  additionalSystemPrompt?: string;
  customPreloadRoutes?: Array<{
    route: string;
    title: string;
    description: string;
    method?: 'GET' | 'POST';
    jsonPath?: string;
    body?: any;
    queryParameters?: Record<string, string>;
    outputFormat?: 'json' | 'string' | 'toon';
    includedFields?: string[];
  }>;
  showResetButton?: boolean;
  className?: string;
  displayType?: 'default' | 'hideForm' | 'showFooter';
  runType?: 'manual' | 'automatic';
  agent?: AiAgent | null; // Optional: If provided, use this agent directly without fetching
}

export function AiBuilderWrapper({
  initialAgentId = '',
  initialUserPrompt = '',
  onClose,
  mode = 'page',
  additionalSystemPrompt = '',
  customPreloadRoutes,
  showResetButton = true,
  className = '',
  displayType = 'default',
  runType = 'manual',
  agent: providedAgent,
}: AiBuilderWrapperProps) {
  const [selectedAgentId, setSelectedAgentId] = useState<string>(initialAgentId);
  const [isSheetOpen, setIsSheetOpen] = useState(false);
  const [previewSchema, setPreviewSchema] = useState<{ schema: FormSchema; schemaId: string } | null>(null);
  const [selectedLanguage, setSelectedLanguage] = useState<string>('en'); // Default language for string output agents
  const [annotations, setAnnotations] = useState<Map<string, SchemaAnnotation>>(new Map());
  const [lastPromptId, setLastPromptId] = useState<string | null>(null);
  const [firstPromptId, setFirstPromptId] = useState<string | null>(null);
  const [previousUserPrompt, setPreviousUserPrompt] = useState<string>('');
  const [previousAiResponse, setPreviousAiResponse] = useState<string>('');
  const [isApplyingAnnotations, setIsApplyingAnnotations] = useState(false);
  const [showResetConfirm, setShowResetConfirm] = useState(false);
  const hasAutoGeneratedRef = useRef(false);
  const [formValues, setFormValues] = useState<Record<string, any>>({});

  // If agent is provided, use it directly without fetching. Otherwise, fetch agents
  // For dialog mode with initialAgentId, fetch only that specific agent
  const agentIdToFetch = !providedAgent && mode === 'dialog' && initialAgentId 
    ? initialAgentId 
    : undefined;
  
  const { agents: fetchedAgents, loading: isLoadingAgents } = useAiAgents(
    providedAgent 
      ? { enabled: false } 
      : (agentIdToFetch ? { agentId: agentIdToFetch } : undefined)
  );
  
  // Use provided agent if available, otherwise use fetched agents
  const agents = providedAgent ? [providedAgent] : fetchedAgents;
  const isLoadingAgentsState = providedAgent ? false : isLoadingAgents;
  const {
    userPrompt,
    setUserPrompt,
    aiResponse,
    tokenUsage,
    duration,
    isLoading,
    isApproving,
    error,
    successMessage,
    preloadedContext,
    isLoadingPreload,
    lastPromptId: hookLastPromptId,
    generateResponse,
    stopGeneration,
    approveResponse,
    loadPreloadRoutes,
    clearResponse,
  } = useAiBuilder();

  // Initialize user prompt if provided (only on mount or when initialUserPrompt changes)
  const [hasInitializedPrompt, setHasInitializedPrompt] = useState(false);
  useEffect(() => {
    if (initialUserPrompt && !hasInitializedPrompt) {
      setUserPrompt(initialUserPrompt);
      setHasInitializedPrompt(true);
    }
  }, [initialUserPrompt, hasInitializedPrompt, setUserPrompt]);

  // Sync hook's lastPromptId with local state
  useEffect(() => {
    if (hookLastPromptId) {
      setLastPromptId(hookLastPromptId);
      if (!firstPromptId) {
        setFirstPromptId(hookLastPromptId);
      }
    }
  }, [hookLastPromptId, firstPromptId]);

  // Track previous prompt and response when a new response is successfully generated
  useEffect(() => {
    if (aiResponse && tokenUsage && !isLoading && hookLastPromptId) {
      if (!isApplyingAnnotations) {
        setAnnotations(new Map());
      }
      
      if (userPrompt) {
        setPreviousUserPrompt(userPrompt);
      }
      if (aiResponse) {
        setPreviousAiResponse(aiResponse);
      }
      
      setIsApplyingAnnotations(false);
    }
  }, [aiResponse, tokenUsage, isLoading, userPrompt, hookLastPromptId, isApplyingAnnotations]);

  // Get selected agent
  const selectedAgent = agents.find(agent => agent.id === selectedAgentId) || null;

  // Set initial agent or first agent as default when agents load
  useEffect(() => {
    if (agents.length > 0 && !selectedAgentId) {
      if (initialAgentId && agents.find(a => a.id === initialAgentId)) {
        setSelectedAgentId(initialAgentId);
      } else {
        setSelectedAgentId(agents[0].id);
      }
    }
  }, [agents, selectedAgentId, initialAgentId]);

  // Clear response when agent changes
  useEffect(() => {
    clearResponse();
    setAnnotations(new Map());
    setFirstPromptId(null);
    setLastPromptId(null);
    setPreviousUserPrompt('');
    setPreviousAiResponse('');
  }, [selectedAgentId, clearResponse]);

  // Load preload routes when agent or sheet opens, or when custom routes are provided
  useEffect(() => {
    if (selectedAgent) {
      if (customPreloadRoutes && customPreloadRoutes.length > 0) {
        // Merge custom preload routes with agent's preload routes
        const mergedAgent = {
          ...selectedAgent,
          preloadRoutes: [
            ...(selectedAgent.preloadRoutes || []),
            ...customPreloadRoutes,
          ],
        };
        loadPreloadRoutes(mergedAgent);
      } else if (isSheetOpen || mode === 'dialog') {
        // For dialog mode, load preload routes immediately if agent has them
        loadPreloadRoutes(selectedAgent);
      }
    }
  }, [isSheetOpen, selectedAgent?.id, loadPreloadRoutes, customPreloadRoutes, mode]);

  // Convert annotations map to array for ResponseAnnotationViewer
  const annotationsArray = Array.from(annotations.values());

  // Get the prompt that would be sent to LLM
  const getPromptForLLM = () => {
    if (!selectedAgent || !userPrompt.trim()) {
      return null;
    }

    // Combine system prompt with preloaded context and additional system prompt
    let systemPrompt = selectedAgent.systemPrompt || '';
    if (additionalSystemPrompt) {
      systemPrompt += (systemPrompt ? '\n\n' : '') + additionalSystemPrompt;
    }
    systemPrompt += (preloadedContext || '');

    // Format user prompt - if annotations are present, include modification request
    const basePrompt = (annotationsArray.length > 0 && previousUserPrompt) ? previousUserPrompt : userPrompt;
    let finalUserPrompt = basePrompt.trim();
    
    if (annotationsArray.length > 0 && previousAiResponse) {
      const annotationSections = annotationsArray.map(ann => {
        const changes = ann.annotations.map(a => `- ${a.label}`).join('\n');
        return `${ann.schemaLabel}\n\n${changes}`;
      }).join('\n\n');
      
      const modificationRequest = `\n\n---\n\n## MODIFY EXISTING SCHEMA(S)\n\nPlease update the following schema(s) based on the requested modifications. Apply ONLY the specified changes while keeping everything else exactly the same.\n\nRequested Modifications:\n\n${annotationSections}\n\nPrevious Schema(s):\n\`\`\`json\n${previousAiResponse}\n\`\`\`\n\n---\n\nIMPORTANT: You are the world's best schema editor. Apply these modifications precisely while preserving all other aspects of the schema(s). Output the complete updated schema(s) in the same format (single object or array).`;
      
      finalUserPrompt = basePrompt.trim() + modificationRequest;
    }

    return {
      systemPrompt,
      userPrompt: finalUserPrompt,
    };
  };

  const handleGenerate = useCallback(() => {
    if (!selectedAgentId) return;
    
    // Calculate body and extra_body from formValues
    let body: Record<string, any> | undefined;
    let extra_body: Record<string, any> | undefined;
    
    if (selectedAgent && Object.keys(formValues).length > 0) {
      const params = extractParametersBySectionId(selectedAgent, formValues);
      body = Object.keys(params.body).length > 0 ? params.body : undefined;
      extra_body = Object.keys(params.extra).length > 0 ? params.extra : undefined;
    }
    
    generateResponse({
      userPrompt,
      agentId: selectedAgentId,
      body,
      extra_body,
    });
  }, [selectedAgentId, userPrompt, generateResponse, selectedAgent, formValues]);

  // Reset auto-generated flag when agent or prompt changes
  useEffect(() => {
    hasAutoGeneratedRef.current = false;
  }, [selectedAgentId, initialUserPrompt]);

  // Auto-generate when runType is automatic and conditions are met (only once)
  useEffect(() => {
    if (
      runType === 'automatic' && 
      !hasAutoGeneratedRef.current &&
      selectedAgentId && 
      userPrompt.trim() && 
      !isLoading && 
      !aiResponse && 
      !isLoadingPreload
    ) {
      // Wait a bit for preload routes to finish loading
      const timer = setTimeout(() => {
        hasAutoGeneratedRef.current = true;
        handleGenerate();
      }, 500);
      return () => clearTimeout(timer);
    }
  }, [runType, selectedAgentId, userPrompt, isLoading, aiResponse, isLoadingPreload, handleGenerate]);

  const handleReset = useCallback(() => {
    setShowResetConfirm(true);
  }, []);

  const handleResetConfirm = useCallback(() => {
    setUserPrompt('');
    setSelectedAgentId('');
    setAnnotations(new Map());
    setPreviousUserPrompt('');
    setPreviousAiResponse('');
    setLastPromptId(null);
    setFirstPromptId(null);
    setPreviewSchema(null);
    setIsApplyingAnnotations(false);
    clearResponse();
    setShowResetConfirm(false);
  }, [setUserPrompt, clearResponse]);

  const handleApplyAnnotations = useCallback(async (annotationsList: SchemaAnnotation[]) => {
    if (!selectedAgentId) {
      console.error('No agent selected');
      return;
    }
    
    const responseToUse = previousAiResponse || aiResponse;
    const promptToUse = previousUserPrompt || userPrompt;
    
    if (!responseToUse) {
      alert('No AI response available. Please generate a response first.');
      return;
    }
    
    if (!promptToUse) {
      alert('No user prompt available. Please enter a prompt first.');
      return;
    }

    const annotationsForSave = annotationsList.map(ann => ({
      schemaId: ann.schemaId,
      schemaName: ann.schemaLabel,
      annotations: ann.annotations,
    }));

    setIsApplyingAnnotations(true);
    
    try {
      await generateResponse({
        userPrompt: promptToUse,
        agentId: selectedAgentId,
        referenceId: firstPromptId || undefined,
        annotations: annotationsForSave,
        previousAiResponse: responseToUse,
        previousUserPrompt: promptToUse,
      });
    } catch (error) {
      console.error('Error generating response with annotations:', error);
      setIsApplyingAnnotations(false);
      alert('Failed to generate response. Please try again.');
    }
  }, [selectedAgentId, previousUserPrompt, previousAiResponse, firstPromptId, generateResponse, aiResponse, userPrompt]);

  const handleApprove = (editedContent?: string) => {
    if (!selectedAgent || !aiResponse) return;
    // Use edited content if provided, otherwise use original response
    const contentToApprove = editedContent || aiResponse;
    approveResponse(contentToApprove, selectedAgent);
  };

  const handleCardClick = useCallback((cardData: { id: string; label: string; icon?: string }, schemaData: any) => {
    const formSchema: FormSchema = schemaData;
    const previewSchemaId = `preview-${cardData.id}`;
    
    setPreviewSchema({
      schema: formSchema,
      schemaId: previewSchemaId,
    });

    if (!annotations.has(cardData.id)) {
      setAnnotations((prev) => {
        const newMap = new Map(prev);
        newMap.set(cardData.id, {
          schemaId: cardData.id,
          schemaLabel: cardData.label,
          schemaIcon: cardData.icon,
          annotations: [],
        });
        return newMap;
      });
    }
  }, [annotations]);

  const handleAnnotationChange = useCallback((schemaId: string, newAnnotations: AnnotationItem[]) => {
    setAnnotations((prev) => {
      const newMap = new Map(prev);
      const existing = newMap.get(schemaId);
      if (existing) {
        newMap.set(schemaId, {
          ...existing,
          annotations: newAnnotations,
        });
      }
      return newMap;
    });
  }, []);

  const handleRemoveSchema = useCallback((schemaId: string) => {
    setAnnotations((prev) => {
      const newMap = new Map(prev);
      newMap.delete(schemaId);
      return newMap;
    });
  }, []);

  const handleFormModalClose = useCallback(() => {
    setPreviewSchema(null);
  }, []);

  const currentSchemaAnnotation = previewSchema 
    ? annotations.get(previewSchema.schema.id) 
    : null;

  const handleModalAnnotationChange = useCallback((items: AnnotationItem[]) => {
    if (previewSchema) {
      const schemaId = previewSchema.schema.id;
      handleAnnotationChange(schemaId, items);
    }
  }, [previewSchema, handleAnnotationChange]);

  const promptForLLM = getPromptForLLM();

  // Skeleton component for loading state
  if (isLoadingAgentsState) {
    return (
      <div className={`space-y-6 ${className}`}>
        <div className="space-y-2 flex flex-col items-center">
          <div className="flex flex-row justify-between items-center flex-wrap gap-2 w-full max-w-3xl">
            <Skeleton className="h-5 w-48 rounded-md bg-gray-300 dark:bg-gray-700" />
            <div className="flex items-center gap-2">
              <Skeleton className="h-10 w-48 rounded-lg bg-gray-300 dark:bg-gray-700" />
              <Skeleton className="h-9 w-32 rounded-md bg-gray-300 dark:bg-gray-700" />
            </div>
          </div>
          
          <div className="relative w-full max-w-3xl">
            <Skeleton className="h-32 w-full rounded-2xl bg-gray-300 dark:bg-gray-700" />
            <div className="absolute inset-0 rounded-2xl bg-linear-to-br from-violet-50/50 via-transparent to-purple-50/50 dark:from-violet-950/20 dark:via-transparent dark:to-purple-950/20" />
          </div>
          
          <div className="flex justify-between items-center w-full max-w-3xl">
            <Skeleton className="h-6 w-28 rounded-full bg-violet-200 dark:bg-violet-900/60" />
            
            <div className="flex items-center gap-2">
              {DEMO_MODE && (
                <Skeleton className="h-10 w-24 rounded-md bg-gray-300 dark:bg-gray-700 opacity-70" />
              )}
              <div className="relative overflow-hidden rounded-md">
                <Skeleton className="h-10 w-36 rounded-md bg-gray-300 dark:bg-gray-700" />
                <div className="absolute inset-0 bg-linear-to-r from-transparent via-white/20 to-transparent dark:via-white/10 animate-shimmer" />
              </div>
            </div>
          </div>
        </div>

        <div className="space-y-4">
          <div className="flex items-center justify-between">
            <Skeleton className="h-7 w-40 rounded-md bg-gray-300 dark:bg-gray-700" />
            <div className="flex items-center gap-3">
              <Skeleton className="h-5 w-64 rounded-md bg-gray-300 dark:bg-gray-700 opacity-80" />
              <Skeleton className="h-10 w-28 rounded-md bg-gray-300 dark:bg-gray-700" />
            </div>
          </div>
          
          <div className="rounded-xl border border-gray-200 dark:border-gray-700 bg-linear-to-br from-gray-50 to-gray-100/50 dark:from-gray-900/50 dark:to-gray-800/30 overflow-hidden">
            <div className="px-4 py-3 border-b border-gray-200 dark:border-gray-700 bg-gray-100/50 dark:bg-gray-800/50">
              <Skeleton className="h-4 w-48 rounded-md bg-gray-300 dark:bg-gray-700" />
            </div>
            <div className="p-4 space-y-2">
              <Skeleton className="h-4 w-full rounded-md bg-gray-300 dark:bg-gray-700" />
              <Skeleton className="h-4 w-5/6 rounded-md bg-gray-300 dark:bg-gray-700 opacity-80" />
              <Skeleton className="h-4 w-4/6 rounded-md bg-gray-300 dark:bg-gray-700 opacity-60" />
            </div>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className={`space-y-6 ${className}`}>
      {displayType !== 'hideForm' && (
        <AiBuilderForm
          userPrompt={userPrompt}
          onPromptChange={setUserPrompt}
          agents={agents}
          selectedAgentId={selectedAgentId}
          onAgentChange={setSelectedAgentId}
          isLoading={isLoading}
          onGenerate={handleGenerate}
          onStop={stopGeneration}
          systemPrompt={promptForLLM?.systemPrompt || ''}
          isLoadingPreload={isLoadingPreload}
          isSheetOpen={isSheetOpen}
          onSheetOpenChange={setIsSheetOpen}
          onReset={showResetButton ? handleReset : undefined}
          displayType={displayType}
          runType={runType}
          selectedLanguage={selectedLanguage}
          onLanguageChange={setSelectedLanguage}
          onFormValuesChange={setFormValues}
        />
      )}

      <MessageDisplay error={error} successMessage={successMessage} />

      <AnimatePresence mode="wait">
        {aiResponse && selectedAgent ? (
          <motion.div
            key="ai-response"
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -20 }}
            transition={{ duration: 0.5, ease: "easeOut" }}
          >
            <AiBuilderResponse
              response={aiResponse}
              agent={selectedAgent}
              tokenUsage={tokenUsage}
              duration={duration}
              isApproving={isApproving}
              isLoading={isLoading}
              onApprove={handleApprove}
              onCardClick={handleCardClick}
              annotations={annotationsArray}
              onAnnotationsChange={handleAnnotationChange}
              onRemoveSchema={handleRemoveSchema}
              onApplyAnnotations={handleApplyAnnotations}
              selectedLanguage={selectedLanguage}
            />
          </motion.div>
        ) : null}
      </AnimatePresence>

      {/* Preview Form Modal with Annotations */}
      {previewSchema && (
        <Modal
          isOpen={!!previewSchema}
          onClose={handleFormModalClose}
          title={`Preview: ${previewSchema.schema.singular_name || previewSchema.schema.name}`}
          description="Review the generated schema and add annotations"
          size="xl"
          showCloseButton={true}
        >
          <div className="space-y-6">
            <SchemaFormWrapper
              schema={previewSchema.schema}
              onSubmit={async () => {
                console.log('Preview mode - form submission disabled');
              }}
              onReset={() => {}}
              onCancel={handleFormModalClose}
              initialValues={{}}
              hideActions={true}
              disabled={false}
              hideCollapseExpandButtons={true}
              forceExpandedSections={true}
              hideGoToTopButton={true}
            />
            
            <div className="border-t border-gray-200 dark:border-gray-700 pt-6 mt-6">
              <h4 className="text-sm font-semibold text-gray-900 dark:text-gray-100 mb-4">
                Add Annotations
              </h4>
              <ListInput
                value={currentSchemaAnnotation?.annotations || []}
                onChange={handleModalAnnotationChange}
                placeholder="Enter annotation..."
                addButtonText="Add Annotation"
                disabled={isLoading}
              />
            </div>
          </div>
        </Modal>
      )}

      {/* Reset Confirmation Dialog */}
      {showResetButton && (
        <ConfirmationMessage
          isOpen={showResetConfirm}
          onOpenChange={setShowResetConfirm}
          title="Reset Everything"
          message="Are you sure you want to reset everything? This will clear your prompt, selected agent, AI response, annotations, and all related data. This action cannot be undone."
          variant="warning"
          buttons={[
            {
              label: 'Cancel',
              variant: 'outline',
              action: () => setShowResetConfirm(false),
            },
            {
              label: 'Reset',
              variant: 'destructive',
              icon: 'RotateCcw',
              action: handleResetConfirm,
            },
          ]}
        />
      )}

      {/* Loading Indicator - Voice Powered Orb */}
      <AiBuilderLoadingIndicator
        isLoading={isLoading && !aiResponse}
        agent={selectedAgent}
        className={mode === 'page' ? 'mt-6' : ''}
      />
    </div>
  );
}

