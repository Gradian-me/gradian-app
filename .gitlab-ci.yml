stages:
  - build
  - deploy

variables:
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: ""

build:
  stage: build
  script:
    - echo "üöÄ Starting Docker image build..."
    - echo "üì¶ Building image with tags latest, $CI_COMMIT_SHORT_SHA"
    - docker build --tag="$CI_REGISTRY_IMAGE:latest" --tag="$CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA" .
    - echo "üîê Authenticating to GitLab registry for pushing images..."
    - |
      # Login to GitLab registry for pushing the built image
      echo "Registry: $CI_REGISTRY"
      echo "Registry Image: $CI_REGISTRY_IMAGE"
      
      # Use CI_JOB_TOKEN (GitLab's recommended method for Container Registry)
      # When using CI_JOB_TOKEN, username should be 'gitlab-ci-token'
      if [ -n "$CI_JOB_TOKEN" ]; then
        echo "Using CI_JOB_TOKEN for GitLab registry authentication"
        REGISTRY_USER="${CI_REGISTRY_USER:-gitlab-ci-token}"
        if ! echo $CI_JOB_TOKEN | docker login -u "$REGISTRY_USER" --password-stdin $CI_REGISTRY; then
          echo "‚ùå Failed to login to GitLab registry with CI_JOB_TOKEN"
          echo "Trying with alternative username..."
          if ! echo $CI_JOB_TOKEN | docker login -u "gitlab-ci-token" --password-stdin $CI_REGISTRY; then
            echo "‚ùå Failed to login to GitLab registry (both usernames)"
            exit 1
          fi
        fi
        echo "‚úÖ Successfully authenticated to GitLab registry"
      elif [ -n "$CI_REGISTRY_PASSWORD" ]; then
        echo "Using CI_REGISTRY_PASSWORD for GitLab registry authentication"
        if ! echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY; then
          echo "‚ùå Failed to login to GitLab registry with CI_REGISTRY_PASSWORD"
          exit 1
        fi
        echo "‚úÖ Successfully authenticated to GitLab registry"
      else
        echo "‚ùå Neither CI_JOB_TOKEN nor CI_REGISTRY_PASSWORD is set"
        echo "One of these is required for pushing to GitLab registry"
        exit 1
      fi
    - echo "üì§ Pushing images to registry..."
    - docker push "$CI_REGISTRY_IMAGE:latest"
    - docker push "$CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA"
    - echo "‚úÖ Build completed!"
  tags:
    - CG-GR-API-DEV
  retry:
    max: 2
    when:
      - runner_system_failure
      - stuck_or_timeout_failure

deploy_staging:
  stage: deploy
  needs:
    - job: build
      artifacts: true   # Use .env from build
  variables:
    # Environment variables for the application
    AVALAI_API_KEY: ${AVALAI_API_KEY}
    CLIENT_ID: ${CLIENT_ID}
    DATABASE_URL: ${DATABASE_URL}
    JWT_SECRET: ${JWT_SECRET}
    NEXTAUTH_SECRET: ${NEXTAUTH_SECRET}
    NEXTAUTH_URL: ${NEXTAUTH_URL}
    NEXT_PUBLIC_CLIENT_ID: ${NEXT_PUBLIC_CLIENT_ID}
    NEXT_PUBLIC_ENCRYPTION_KEY: ${NEXT_PUBLIC_ENCRYPTION_KEY}
    NEXT_PUBLIC_SCHEMA_API_BASE: ${NEXT_PUBLIC_SCHEMA_API_BASE}
    NEXT_PUBLIC_SECRET_KEY: ${NEXT_PUBLIC_SECRET_KEY}
    NEXT_PUBLIC_URL_DATA_CRUD: ${NEXT_PUBLIC_URL_DATA_CRUD}
    NEXT_PUBLIC_URL_SCHEMA_CRUD: ${NEXT_PUBLIC_URL_SCHEMA_CRUD}
    NEXT_PUBLIC_URL_SYNC_MAIL_TEMPLATE: ${NEXT_PUBLIC_URL_SYNC_MAIL_TEMPLATE}
    PEPPER: ${PEPPER}
    SECRET_KEY: ${SECRET_KEY}
    URL_DATA_CRUD: ${URL_DATA_CRUD}
    URL_SCHEMA_CRUD: ${URL_SCHEMA_CRUD}
    URL_SEND_EMAIL: ${URL_SEND_EMAIL}
    URL_SYNC_MAIL_TEMPLATE: ${URL_SYNC_MAIL_TEMPLATE}
  before_script:
    - |
      # Configure Docker to use insecure registry (for self-signed or expired certificates)
      # Extract registry hostname from CI_REGISTRY
      REGISTRY_HOST=$(echo $CI_REGISTRY | sed 's|https\?://||' | sed 's|:.*||')
      REGISTRY_PORT=$(echo $CI_REGISTRY | sed 's|https\?://||' | sed 's|.*:||' | sed 's|/.*||')
      echo "Configuring Docker for insecure registry: $REGISTRY_HOST:$REGISTRY_PORT"
      
      # Try to configure Docker daemon (requires sudo, may fail on some runners)
      if command -v sudo >/dev/null 2>&1; then
        if [ -f /etc/docker/daemon.json ]; then
          echo "Backing up existing daemon.json"
          sudo cp /etc/docker/daemon.json /etc/docker/daemon.json.bak 2>/dev/null || true
          # Add insecure-registries if not already present
          if command -v jq >/dev/null 2>&1; then
            sudo jq --arg host "$REGISTRY_HOST:$REGISTRY_PORT" '.insecure-registries = (.insecure-registries // []) + [$host] | unique' /etc/docker/daemon.json > /tmp/daemon.json 2>/dev/null && sudo mv /tmp/daemon.json /etc/docker/daemon.json || echo "Could not modify daemon.json (may need manual configuration)"
          else
            echo "jq not available, skipping daemon.json modification"
          fi
        else
          echo "Creating new daemon.json"
          echo "{\"insecure-registries\": [\"$REGISTRY_HOST:$REGISTRY_PORT\"]}" | sudo tee /etc/docker/daemon.json > /dev/null 2>/dev/null || echo "Could not create daemon.json (may need manual configuration)"
        fi
        
        # Try to restart Docker daemon (may fail if no permission)
        echo "Attempting to restart Docker daemon..."
        sudo systemctl restart docker 2>/dev/null || sudo service docker restart 2>/dev/null || echo "Could not restart Docker daemon (may need manual restart or configuration)"
        sleep 3
      else
        echo "sudo not available, skipping Docker daemon configuration"
        echo "‚ö†Ô∏è  WARNING: Docker daemon may need to be configured manually with insecure-registries"
        echo "Add to /etc/docker/daemon.json: {\"insecure-registries\": [\"$REGISTRY_HOST:$REGISTRY_PORT\"]}"
      fi
  script:
    - echo "üöÄ Starting deployment..."
    - echo "üîê Authenticating to GitLab registry for pulling images..."
    - |
      # Convert HTTPS to HTTP for registry URL (bypasses TLS certificate issues)
      # Extract registry hostname and port
      export REGISTRY_HOST_PORT=$(echo $CI_REGISTRY | sed 's|https\?://||' | sed 's|/.*||')
      export REGISTRY_HTTP="http://$REGISTRY_HOST_PORT"
      export REGISTRY_HTTPS="$CI_REGISTRY"
      
      echo "Registry (HTTPS): $REGISTRY_HTTPS"
      echo "Registry (HTTP): $REGISTRY_HTTP"
      echo "Registry Image: $CI_REGISTRY_IMAGE"
      
      # Try HTTP first (if nginx supports it), then fall back to HTTPS with insecure flag
      # Use CI_JOB_TOKEN (GitLab's recommended method for Container Registry)
      # When using CI_JOB_TOKEN, username should be 'gitlab-ci-token'
      if [ -n "$CI_JOB_TOKEN" ]; then
        echo "Using CI_JOB_TOKEN for GitLab registry authentication"
        REGISTRY_USER="${CI_REGISTRY_USER:-gitlab-ci-token}"
        
        # Try HTTP first
        if echo $CI_JOB_TOKEN | docker login -u "$REGISTRY_USER" --password-stdin $REGISTRY_HTTP 2>/dev/null; then
          echo "‚úÖ Successfully authenticated to GitLab registry via HTTP"
          export DOCKER_REGISTRY_URL="$REGISTRY_HTTP"
        # Try HTTPS with HTTP registry
        elif echo $CI_JOB_TOKEN | docker login -u "$REGISTRY_USER" --password-stdin $REGISTRY_HTTPS 2>/dev/null; then
          echo "‚úÖ Successfully authenticated to GitLab registry via HTTPS"
          export DOCKER_REGISTRY_URL="$REGISTRY_HTTPS"
        else
          echo "‚ùå Failed to login to GitLab registry with CI_JOB_TOKEN"
          echo "Trying with alternative username..."
          if echo $CI_JOB_TOKEN | docker login -u "gitlab-ci-token" --password-stdin $REGISTRY_HTTP 2>/dev/null; then
            echo "‚úÖ Successfully authenticated via HTTP with alternative username"
            export DOCKER_REGISTRY_URL="$REGISTRY_HTTP"
          elif echo $CI_JOB_TOKEN | docker login -u "gitlab-ci-token" --password-stdin $REGISTRY_HTTPS 2>/dev/null; then
            echo "‚úÖ Successfully authenticated via HTTPS with alternative username"
            export DOCKER_REGISTRY_URL="$REGISTRY_HTTPS"
          else
            echo "‚ùå Failed to login to GitLab registry (both usernames and both protocols)"
            exit 1
          fi
        fi
      elif [ -n "$CI_REGISTRY_PASSWORD" ]; then
        echo "Using CI_REGISTRY_PASSWORD for GitLab registry authentication"
        if echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $REGISTRY_HTTP 2>/dev/null; then
          echo "‚úÖ Successfully authenticated via HTTP"
          export DOCKER_REGISTRY_URL="$REGISTRY_HTTP"
        elif echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $REGISTRY_HTTPS 2>/dev/null; then
          echo "‚úÖ Successfully authenticated via HTTPS"
          export DOCKER_REGISTRY_URL="$REGISTRY_HTTPS"
        else
          echo "‚ùå Failed to login to GitLab registry with CI_REGISTRY_PASSWORD"
          exit 1
        fi
      else
        echo "‚ùå Neither CI_JOB_TOKEN nor CI_REGISTRY_PASSWORD is set"
        echo "One of these is required for pulling from GitLab registry"
        exit 1
      fi
    - |
      # Convert CI_REGISTRY_IMAGE to use HTTP if we logged in via HTTP
      if [ "$DOCKER_REGISTRY_URL" = "http://$REGISTRY_HOST_PORT" ]; then
        echo "Converting CI_REGISTRY_IMAGE to use HTTP protocol"
        export CI_REGISTRY_IMAGE=$(echo $CI_REGISTRY_IMAGE | sed 's|https://|http://|')
        echo "Updated CI_REGISTRY_IMAGE: $CI_REGISTRY_IMAGE"
      fi
    - echo "üì• Pulling latest images..."
    - docker compose pull
    - docker compose down --remove-orphans || true
    - docker compose up -d
    - echo "üè• Performing health check..."
    - sleep 10
    - docker compose ps
    - echo "üßπ Cleaning up old images..."
    - |
      docker images --format "table {{.Repository}}:{{.Tag}}\t{{.ID}}" | grep "$CI_REGISTRY_IMAGE" | grep -v "latest" | awk '{print $2}' | xargs -r docker rmi || echo "No old images to remove"
      docker image prune -f
      echo "üìã Remaining images:"
      docker images | grep "$CI_REGISTRY_IMAGE" || echo "No images found"
    - echo "‚úÖ Deployment completed!"
  environment:
    name: staging
    url: https://staging.gradian-api.com
  tags:
    - CG-GR-APP-PRD-1
  retry:
    max: 2
    when:
      - runner_system_failure
      - stuck_or_timeout_failure
