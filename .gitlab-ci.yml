stages:
  - security
  - security_approval
  - build
  - image_scan
  - image_approval
  - deploy

variables:
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: ""
  DOCKER_BUILDKIT: "1"


before_script:
  - echo "Authenticating with Docker Registry..."
  - echo "$nexus_password" | docker login -u "$nexus_user" --password-stdin reg.cinnagen.com:8083
  - echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
  
security_audit:
  stage: security
  script:
    - echo "üîí Starting security audit..."
    - |
      if [ ! -f "package.json" ]; then
        echo "‚ùå package.json not found!"
        exit 1
      fi
    - echo "üì¶ Installing dependencies..."
    - npm ci --prefer-offline
    - echo ""
    - |
      echo "========================================="
      echo "üîí Security Audit Report"
      echo "========================================="
      echo "üìÖ Date: $(date)"
      echo "üîñ Commit: $CI_COMMIT_SHORT_SHA"
      echo "üåø Branch: $CI_COMMIT_REF_NAME"
      echo ""
    - |
      echo "========================================="
      echo "üö® Vulnerability Report"
      echo "========================================="
      echo ""
      HAS_VULNERABILITIES=false
      # Capture npm audit output and exit code
      # Run npm audit against the public npm registry, skip on error
      AUDIT_OUTPUT=$(npm audit --audit-level=moderate --registry=https://registry.npmjs.org/ 2>&1) || {
        AUDIT_EXIT_CODE=0
        echo "‚ö†Ô∏è Audit skipped (using Nexus registry blocked this endpoint)"
      }

      # Display the audit output
      echo "$AUDIT_OUTPUT"
      echo ""
      # Check if vulnerabilities were found
      if [ -n "$AUDIT_EXIT_CODE" ] && [ "$AUDIT_EXIT_CODE" -ne 0 ]; then
        echo "‚ùå Security audit failed: Vulnerabilities found!"
        HAS_VULNERABILITIES=true
      else
        echo "‚úÖ No vulnerabilities found"
      fi
      echo ""
      echo "========================================="
      echo "‚ö†Ô∏è  Deprecated Packages Report"
      echo "========================================="
      echo ""
      HAS_DEPRECATED=false
      DEPRECATED_OUTPUT=$(npm ls --depth=0 2>&1 | grep -i "deprecated" || true)
      if [ -n "$DEPRECATED_OUTPUT" ]; then
        echo "$DEPRECATED_OUTPUT"
        echo ""
        echo "‚ùå Security audit failed: Deprecated packages found!"
        HAS_DEPRECATED=true
      else
        echo "‚úÖ No deprecated packages found"
      fi
      echo ""
      echo "========================================="
      if [ "$HAS_VULNERABILITIES" = "true" ] || [ "$HAS_DEPRECATED" = "true" ]; then
        echo "‚ùå Security audit failed!"
        exit 1
      fi
      echo "‚úÖ Security audit passed! No vulnerabilities or deprecated packages found."
  tags:
    - CG-GR-APP-DEV-shell
  only:
    - main
    - master
  allow_failure: true
  retry:
    max: 2
    when:
      - runner_system_failure
      - stuck_or_timeout_failure

owasp_dependency_check:
  stage: security
  script:
    - echo "üõ°Ô∏è Starting OWASP Dependency-Check scan..."
    - |
      echo "========================================="
      echo "üõ°Ô∏è OWASP Dependency-Check Report"
      echo "========================================="
      echo "üìÖ Date: $(date)"
      echo "üîñ Commit: $CI_COMMIT_SHORT_SHA"
      echo "üåø Branch: $CI_COMMIT_REF_NAME"
      echo ""
    - |
      if [ ! -f "package.json" ]; then
        echo "‚ùå package.json not found!"
        exit 1
      fi
    - |
      # Create temporary report directory (will be deleted after displaying)
      export TEMP_REPORT_DIR=$(mktemp -d)
      echo "üì¶ Preparing project for OWASP scan..."
      echo "üìÅ Temporary report directory: $TEMP_REPORT_DIR"
      # OWASP Dependency-Check can scan package.json and package-lock.json directly
      # It will also check node_modules if available, but it's not required
      if [ -d "node_modules" ]; then
        echo "‚úÖ node_modules found - will be included in scan"
      else
        echo "‚ÑπÔ∏è  node_modules not found - scanning package.json and package-lock.json only"
      fi
      echo "üê≥ Pulling OWASP Dependency-Check Docker image..."
      docker pull reg.cinnagen.com:8083/owasp/dependency-check:latest
      echo "üîç Running OWASP Dependency-Check against NVD database..."
      # Get absolute paths for volume mounting
      PROJECT_DIR=$(pwd)
      
      # Ensure report directory is writable
      chmod 777 "$TEMP_REPORT_DIR" 2>/dev/null || true
      
      # Build base docker command
      # Note: Some Node.js-specific options are not available in CLI version
      # Using container name to copy files after execution
      CONTAINER_NAME="owasp-dc-$(date +%s)"
      
      DOCKER_ARGS=(
        --name "$CONTAINER_NAME"
        -v "$PROJECT_DIR:/src:ro"
        -v "$TEMP_REPORT_DIR:/report:rw"
        -w /src
        reg.cinnagen.com:8083/owasp/dependency-check:latest
        --project "gradian-app"
        --scan /src
        --format "JSON"
        --out /report
        --enableExperimental
        --failOnCVSS 7
      )
      
      # Add NVD API key if provided
      if [ -n "$NVD_API_KEY" ]; then
        DOCKER_ARGS+=(--nvdApiKey "$NVD_API_KEY")
        echo "üîë Using NVD API Key"
      else
        echo "‚ÑπÔ∏è  No NVD API Key provided (using public NVD API)"
      fi
      
      # Run OWASP Dependency-Check
      echo "üöÄ Executing OWASP Dependency-Check..."
      docker run "${DOCKER_ARGS[@]}" || OWASP_EXIT_CODE=$?
      
      # Try to copy report from container if volume mount didn't work
      if [ ! -f "$TEMP_REPORT_DIR/dependency-check-report.json" ]; then
        echo "‚ö†Ô∏è  Report not found in volume mount, trying to copy from container..."
        docker cp "$CONTAINER_NAME:/report/dependency-check-report.json" "$TEMP_REPORT_DIR/" 2>/dev/null || true
      fi
      
      # Clean up container
      docker rm -f "$CONTAINER_NAME" 2>/dev/null || true
      
      echo ""
      echo "========================================="
      echo "üìä OWASP Dependency-Check Results"
      echo "========================================="
      
      # Display report in log
      REPORT_FILE="$TEMP_REPORT_DIR/dependency-check-report.json"
      
      # Check if report file exists
      if [ -f "$REPORT_FILE" ]; then
        echo ""
        echo "üìã Vulnerability Summary:"
        echo "----------------------------------------"
        # Extract and display summary using jq if available
        if command -v jq >/dev/null 2>&1; then
          # Count total dependencies
          TOTAL_DEPS=$(jq '.dependencies | length' "$REPORT_FILE" 2>/dev/null || echo "0")
          echo "üì¶ Total dependencies scanned: $TOTAL_DEPS"
          
          # Count vulnerable dependencies
          VULN_DEPS=$(jq '[.dependencies[] | select(.vulnerabilities != null and (.vulnerabilities | length) > 0)] | length' "$REPORT_FILE" 2>/dev/null || echo "0")
          echo "üö® Vulnerable dependencies: $VULN_DEPS"
          
          # Display vulnerable packages with details
          if [ "$VULN_DEPS" -gt 0 ]; then
            echo ""
            echo "‚ö†Ô∏è  Vulnerable Packages:"
            echo "----------------------------------------"
            jq -r '.dependencies[] | select(.vulnerabilities != null and (.vulnerabilities | length) > 0) | 
              "Package: \(.packages[0].id // .fileName)\n" +
              "Vulnerabilities: \(.vulnerabilities | length)\n" +
              (.vulnerabilities[] | "  - \(.name): CVSS \(.cvssv3.baseScore // .cvssv2.score // "N/A") - \(.description // "No description")[0:100]\n") +
              "---"' "$REPORT_FILE" 2>/dev/null || echo "Could not parse vulnerability details"
          fi
          
          # Display full JSON report
          echo ""
          echo "üìÑ Full JSON Report:"
          echo "----------------------------------------"
          cat "$REPORT_FILE"
        else
          # If jq is not available, just display the raw JSON
          echo "üìÑ Full JSON Report:"
          echo "----------------------------------------"
          cat "$REPORT_FILE"
        fi
        echo ""
        echo "----------------------------------------"
      else
        echo "‚ö†Ô∏è  Report file not found at $REPORT_FILE"
        echo ""
        echo "‚ÑπÔ∏è  Checking for alternative report locations..."
        # Try to find any JSON files in temp directory
        if ls "$TEMP_REPORT_DIR"/*.json 1> /dev/null 2>&1; then
          echo "üìÑ Found alternative report files:"
          ls -lh "$TEMP_REPORT_DIR"/*.json
          echo ""
          echo "üìÑ Displaying first JSON file found:"
          FIRST_JSON=$(ls "$TEMP_REPORT_DIR"/*.json | head -1)
          cat "$FIRST_JSON"
        else
          echo "‚ùå No report files found. Analysis may have completed but report generation failed."
          echo "‚ÑπÔ∏è  Check the OWASP Dependency-Check output above for analysis results."
        fi
      fi
      
      # Check if report exists before cleanup
      REPORT_EXISTS=false
      if [ -f "$TEMP_REPORT_DIR/dependency-check-report.json" ] || ls "$TEMP_REPORT_DIR"/*.json 1> /dev/null 2>&1; then
        REPORT_EXISTS=true
      fi
      
      # Clean up temporary directory
      echo "üßπ Cleaning up temporary files..."
      rm -rf "$TEMP_REPORT_DIR"
      echo "‚úÖ Temporary files removed"
      
      echo ""
      # Check exit code and fail if vulnerabilities found
      
      if [ -n "$OWASP_EXIT_CODE" ] && [ "$OWASP_EXIT_CODE" -ne 0 ]; then
        echo "‚ùå OWASP Dependency-Check FAILED!"
        echo "üö® High/Critical vulnerabilities (CVSS >= 7) detected!"
        if [ "$REPORT_EXISTS" = "false" ]; then
          echo "‚ö†Ô∏è  Note: Report file was not generated, but scan detected vulnerabilities."
        fi
        exit 1
      else
        if [ "$REPORT_EXISTS" = "false" ]; then
          echo "‚ö†Ô∏è  OWASP Dependency-Check completed, but report file was not generated."
          echo "‚úÖ Scan completed without detecting high/critical vulnerabilities (CVSS >= 7)"
        else
          echo "‚úÖ OWASP Dependency-Check PASSED!"
          echo "‚úÖ No high/critical vulnerabilities (CVSS >= 7) found in dependencies"
        fi
      fi
  tags:
    - CG-GR-APP-DEV
  only:
    - main
    - master
  when: manual
  retry:
    max: 2
    when:
      - runner_system_failure
      - stuck_or_timeout_failure

semgrep_sast:
  stage: security
  script:
    - echo "üîç Starting Semgrep SAST scan..."
    - |
      echo "========================================="
      echo "üîç Semgrep SAST Report"
      echo "========================================="
      echo "üìÖ Date: $(date)"
      echo "üîñ Commit: $CI_COMMIT_SHORT_SHA"
      echo "üåø Branch: $CI_COMMIT_REF_NAME"
      echo ""
    - |
      # Create temporary directory for report
      export TEMP_REPORT_DIR=$(mktemp -d)
      echo "üìÅ Temporary report directory: $TEMP_REPORT_DIR"
      
      # Get absolute path for volume mounting
      PROJECT_DIR=$(pwd)
      
      echo "üê≥ Pulling Semgrep Docker image..."
      docker pull reg.cinnagen.com:8083/returntocorp/semgrep:latest
      
      echo "üîç Running Semgrep SAST scan..."
      # Ensure report directory is writable
      chmod 777 "$TEMP_REPORT_DIR" 2>/dev/null || true
      
      # Run Semgrep with JSON output
      # Using container name to copy files after execution
      CONTAINER_NAME="semgrep-sast-$(date +%s)"
      
      # Run Semgrep scan
      # --config=auto: Use Semgrep's auto-config for the project
      # --json: Output in JSON format
      # --output: Output file path (inside container, will be mounted)
      # --error: Exit with non-zero code if findings are found
      docker run \
        --name "$CONTAINER_NAME" \
        -v "$PROJECT_DIR:/src:ro" \
        -v "$TEMP_REPORT_DIR:/report:rw" \
        -w /src \
        reg.cinnagen.com:8083/returntocorp/semgrep:latest \
        semgrep \
        --config=auto \
        --json \
        --output=/report/semgrep-report.json \
        --error \
        /src || SEMGREP_EXIT_CODE=$?
      
      # Try to copy report from container if volume mount didn't work
      if [ ! -f "$TEMP_REPORT_DIR/semgrep-report.json" ]; then
        echo "‚ö†Ô∏è  Report not found in volume mount, trying to copy from container..."
        docker cp "$CONTAINER_NAME:/report/semgrep-report.json" "$TEMP_REPORT_DIR/" 2>/dev/null || true
      fi
      
      # Clean up container
      docker rm -f "$CONTAINER_NAME" 2>/dev/null || true
      
      echo ""
      echo "========================================="
      echo "üìä Semgrep SAST Results"
      echo "========================================="
      
      # Display report in log
      REPORT_FILE="$TEMP_REPORT_DIR/semgrep-report.json"
      
      if [ -f "$REPORT_FILE" ]; then
        echo ""
        echo "üìã Security Findings Summary:"
        echo "----------------------------------------"
        
        # Extract and display summary using jq if available
        if command -v jq >/dev/null 2>&1; then
          # Count total findings
          TOTAL_FINDINGS=$(jq '.results | length' "$REPORT_FILE" 2>/dev/null || echo "0")
          echo "üîç Total findings: $TOTAL_FINDINGS"
          
          # Count findings by severity
          if [ "$TOTAL_FINDINGS" -gt 0 ]; then
            ERROR_COUNT=$(jq '[.results[] | select(.extra.severity == "ERROR")] | length' "$REPORT_FILE" 2>/dev/null || echo "0")
            WARNING_COUNT=$(jq '[.results[] | select(.extra.severity == "WARNING")] | length' "$REPORT_FILE" 2>/dev/null || echo "0")
            INFO_COUNT=$(jq '[.results[] | select(.extra.severity == "INFO")] | length' "$REPORT_FILE" 2>/dev/null || echo "0")
            
            echo "üö® ERROR severity: $ERROR_COUNT"
            echo "‚ö†Ô∏è  WARNING severity: $WARNING_COUNT"
            echo "‚ÑπÔ∏è  INFO severity: $INFO_COUNT"
            
            # Display findings details
            echo ""
            echo "‚ö†Ô∏è  Security Findings:"
            echo "----------------------------------------"
            jq -r '.results[] | 
              "File: \(.path)\n" +
              "Rule: \(.check_id)\n" +
              "Severity: \(.extra.severity)\n" +
              "Message: \(.message)\n" +
              "Line: \(.start.line)-\(.end.line)\n" +
              "---"' "$REPORT_FILE" 2>/dev/null || echo "Could not parse findings details"
          fi
          
          # Display full JSON report
          echo ""
          echo "üìÑ Full JSON Report:"
          echo "----------------------------------------"
          cat "$REPORT_FILE"
        else
          # If jq is not available, just display the raw JSON
          echo "üìÑ Full JSON Report:"
          echo "----------------------------------------"
          cat "$REPORT_FILE"
        fi
        echo ""
        echo "----------------------------------------"
      else
        echo "‚ö†Ô∏è  Report file not found at $REPORT_FILE"
        echo "‚ÑπÔ∏è  Semgrep scan completed, but report file was not generated."
      fi
      
      # Clean up temporary directory
      echo "üßπ Cleaning up temporary files..."
      rm -rf "$TEMP_REPORT_DIR"
      echo "‚úÖ Temporary files removed"
      
      echo ""
      # Check exit code and fail if findings found
      # Semgrep returns exit code 2 when findings are found (with --error flag)
      # Exit code 1 is for other errors
      if [ -n "$SEMGREP_EXIT_CODE" ] && [ "$SEMGREP_EXIT_CODE" -ne 0 ]; then
        if [ "$SEMGREP_EXIT_CODE" -eq 2 ]; then
          echo "‚ùå Semgrep SAST FAILED!"
          echo "üö® Security findings detected in code!"
        else
          echo "‚ùå Semgrep SAST FAILED!"
          echo "‚ö†Ô∏è  Semgrep scan encountered an error (exit code: $SEMGREP_EXIT_CODE)"
        fi
        exit 1
      else
        echo "‚úÖ Semgrep SAST PASSED!"
        echo "‚úÖ No security findings detected in code"
      fi
  tags:
    - CG-GR-APP-DEV
  only:
    - main
    - master
  when: manual
  allow_failure: true
  retry:
    max: 2
    when:
      - runner_system_failure
      - stuck_or_timeout_failure

security_approval:
  stage: security_approval
  script:
    - |
      echo "========================================="
      echo "üîê Security Scan Approval Required"
      echo "========================================="
      echo ""
      echo "üìã Security Scan Results Summary:"
      echo "----------------------------------------"
      echo ""
      echo "Please review the security scan results above."
      echo "If any security scans failed, please review the findings"
      echo "and approve to continue with build and deployment."
      echo ""
      echo "‚úÖ Click 'Play' button to approve and continue"
      echo "‚ùå Or cancel this pipeline to stop"
      echo ""
      echo "========================================="
  tags:
    - CG-GR-APP-DEV
  only:
    - main
    - master
  when: manual
  allow_failure: false

build:
  stage: build
  needs:
    - job: security_approval
      artifacts: false
  cache:
    key: 
      files:
        - package-lock.json
    paths:
      - .npm/
      - node_modules/
    policy: pull-push
  artifacts:
    name: "build-artifacts-$CI_COMMIT_SHORT_SHA"
    paths:
      - .env
      - .next/
      - node_modules/
    expire_in: 1 week
    when: on_success
  script:
    - echo "‚öôÔ∏è Setting up environment files..."
    - |
      cat > .env << EOF
      AVALAI_API_KEY=$AVALAI_API_KEY
      APP_ID=$APP_ID
      URL_AUTHENTICATION=$URL_AUTHENTICATION
      APP_SECRET_KEY=$APP_SECRET_KEY
      CLIENT_ID=$CLIENT_ID
      DATABASE_URL=$DATABASE_URL
      JWT_SECRET=$JWT_SECRET
      NEXTAUTH_SECRET=$NEXTAUTH_SECRET
      NEXTAUTH_URL=$NEXTAUTH_URL
      NEXT_PUBLIC_CLIENT_ID=$NEXT_PUBLIC_CLIENT_ID
      NEXT_PUBLIC_ENCRYPTION_KEY=$NEXT_PUBLIC_ENCRYPTION_KEY
      NEXT_PUBLIC_SCHEMA_API_BASE=$NEXT_PUBLIC_SCHEMA_API_BASE
      NEXT_PUBLIC_SECRET_KEY=$NEXT_PUBLIC_SECRET_KEY
      NEXT_PUBLIC_URL_DATA_CRUD=$NEXT_PUBLIC_URL_DATA_CRUD
      NEXT_PUBLIC_URL_SCHEMA_CRUD=$NEXT_PUBLIC_URL_SCHEMA_CRUD
      NEXT_PUBLIC_URL_SYNC_MAIL_TEMPLATE=$NEXT_PUBLIC_URL_SYNC_MAIL_TEMPLATE
      PEPPER=$PEPPER
      SECRET_KEY=$SECRET_KEY
      URL_DATA_CRUD=$URL_DATA_CRUD
      URL_SCHEMA_CRUD=$URL_SCHEMA_CRUD
      URL_SEND_EMAIL=$URL_SEND_EMAIL
      URL_SYNC_MAIL_TEMPLATE=$URL_SYNC_MAIL_TEMPLATE
      DEMO_MODE=$DEMO_MODE
      NEXT_PUBLIC_SKIP_KEY=$NEXT_PUBLIC_SKIP_KEY
      REQUIRE_LOGIN=$REQUIRE_LOGIN
      INTERNAL_API_BASE_URL=$INTERNAL_API_BASE_URL
      ENABLE_LOGGING=${ENABLE_LOGGING:-false}
      NEXT_PUBLIC_ENABLE_LOGGING=${NEXT_PUBLIC_ENABLE_LOGGING:-false}
      EOF
    - echo "üöÄ Starting Docker image build..."
    - echo "üì¶ Building image with tags latest, $CI_COMMIT_SHORT_SHA"
    - echo "üíæ Using BuildKit cache for faster builds..."
    - echo "üì¶ Using GitLab CI cache for node_modules..."
    - export DOCKER_BUILDKIT=1
    - |
      # Build with BuildKit cache from registry
      docker build \
        --tag="$CI_REGISTRY_IMAGE:latest" \
        --tag="$CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA" \
        --build-arg NODE_ENV=$NODE_ENV \
        --build-arg NEXT_PUBLIC_ENCRYPTION_KEY=$NEXT_PUBLIC_ENCRYPTION_KEY \
        --build-arg NEXT_PUBLIC_SKIP_KEY=$NEXT_PUBLIC_SKIP_KEY \
        --cache-from "$CI_REGISTRY_IMAGE:latest" \
        .
    - echo "üì§ Pushing images to registry..."
    - docker push "$CI_REGISTRY_IMAGE:latest"
    - docker push "$CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA"
    - echo "‚úÖ Build completed!"
  tags:
    - CG-GR-APP-DEV
  only:
    - main
    - master
  retry:
    max: 2
    when:
      - runner_system_failure
      - stuck_or_timeout_failure

trivy_image_scan:
  stage: build
  needs:
    - job: build
  script:
    - echo "üîí Starting Trivy Docker Image Security Scan..."
    - |
      echo "========================================="
      echo "üîí Trivy Image Security Scan Report"
      echo "========================================="
      echo "üìÖ Date: $(date)"
      echo "üîñ Commit: $CI_COMMIT_SHORT_SHA"
      echo "üåø Branch: $CI_COMMIT_REF_NAME"
      echo "üê≥ Image: $CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA"
      echo ""
    - |
      # Create temporary directory for report
      export TEMP_REPORT_DIR=$(mktemp -d)
      echo "üìÅ Temporary report directory: $TEMP_REPORT_DIR"
      
      # Get absolute path for volume mounting
      PROJECT_DIR=$(pwd)
      
      echo "üê≥ Pulling Trivy Docker image..."
      docker pull reg.cinnagen.com:8083/aquasec/trivy:latest
      
      echo "üîç Running Trivy security scan on Docker image..."
      # Ensure report directory is writable
      chmod 777 "$TEMP_REPORT_DIR" 2>/dev/null || true
      
      # Run Trivy scan
      # Using container name to copy files after execution
      CONTAINER_NAME="trivy-scan-$(date +%s)"
      
      # Run Trivy scan
      # image: The Docker image to scan
      # --format json: Output in JSON format
      # --output: Output file path
      # --exit-code 0: Don't fail on vulnerabilities (we'll check separately)
      # --severity HIGH,CRITICAL: Only report HIGH and CRITICAL vulnerabilities
      # --no-progress: Disable progress bar
      # --skip-db-update: Skip database update (faster, but may miss latest vulnerabilities)
      IMAGE_TO_SCAN="$CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA"
      
      # Mount Docker config for registry authentication
      DOCKER_CONFIG_DIR="${HOME}/.docker"
      DOCKER_CONFIG_MOUNT=""
      if [ -d "$DOCKER_CONFIG_DIR" ]; then
        DOCKER_CONFIG_MOUNT="-v $DOCKER_CONFIG_DIR:/root/.docker:ro"
        echo "üîë Using Docker config for registry authentication"
      fi
      
      docker run \
        --name "$CONTAINER_NAME" \
        --rm \
        -v /mnt/data/program/trivy_data:/root/.cache/trivy \
        -e TRIVY_DISABLE_JAVA=true \
        -v /var/run/docker.sock:/var/run/docker.sock \
        $DOCKER_CONFIG_MOUNT \
        -v "$TEMP_REPORT_DIR:/report:rw" \
        reg.cinnagen.com:8083/aquasec/trivy:latest \
        image \
        --scanners vuln,misconfig,secret \
        --skip-db-update \
        --skip-java-db-update \
        --skip-check-update \
        --ignore-unfixed \
        --severity HIGH,CRITICAL \
        --offline-scan \
        --format json \
        --output /report/trivy-report.json \
        --exit-code 1 \
        "$IMAGE_TO_SCAN" 2>&1 || TRIVY_HAS_VULNS=$?
      
      echo ""
      echo "========================================="
      echo "üìä Trivy Image Security Scan Results"
      echo "========================================="
      
      # Display report in log
      REPORT_FILE="$TEMP_REPORT_DIR/trivy-report.json"
      
      if [ -f "$REPORT_FILE" ]; then
        echo ""
        echo "üìã Vulnerability Summary:"
        echo "----------------------------------------"
        
        # Extract and display summary using jq if available
        if command -v jq >/dev/null 2>&1; then
          # Count total vulnerabilities
          TOTAL_VULNS=$(jq '[.Results[]?.Vulnerabilities[]?] | length' "$REPORT_FILE" 2>/dev/null || echo "0")
          echo "üîç Total vulnerabilities: $TOTAL_VULNS"
          
          # Count by severity
          if [ "$TOTAL_VULNS" -gt 0 ]; then
            CRITICAL_COUNT=$(jq '[.Results[]?.Vulnerabilities[]? | select(.Severity == "CRITICAL")] | length' "$REPORT_FILE" 2>/dev/null || echo "0")
            HIGH_COUNT=$(jq '[.Results[]?.Vulnerabilities[]? | select(.Severity == "HIGH")] | length' "$REPORT_FILE" 2>/dev/null || echo "0")
            MEDIUM_COUNT=$(jq '[.Results[]?.Vulnerabilities[]? | select(.Severity == "MEDIUM")] | length' "$REPORT_FILE" 2>/dev/null || echo "0")
            LOW_COUNT=$(jq '[.Results[]?.Vulnerabilities[]? | select(.Severity == "LOW")] | length' "$REPORT_FILE" 2>/dev/null || echo "0")
            
            echo "üö® CRITICAL: $CRITICAL_COUNT"
            echo "‚ö†Ô∏è  HIGH: $HIGH_COUNT"
            echo "‚ÑπÔ∏è  MEDIUM: $MEDIUM_COUNT"
            echo "‚ÑπÔ∏è  LOW: $LOW_COUNT"
            
            # Display critical and high vulnerabilities
            if [ "$CRITICAL_COUNT" -gt 0 ] || [ "$HIGH_COUNT" -gt 0 ]; then
              echo ""
              echo "‚ö†Ô∏è  Critical/High Vulnerabilities:"
              echo "----------------------------------------"
              jq -r '.Results[]?.Vulnerabilities[]? | 
                select(.Severity == "CRITICAL" or .Severity == "HIGH") |
                "Package: \(.PkgName)\n" +
                "Vulnerability: \(.VulnerabilityID)\n" +
                "Severity: \(.Severity)\n" +
                "Title: \(.Title // "N/A")\n" +
                "Description: \(.Description // "N/A")[0:150]\n" +
                "---"' "$REPORT_FILE" 2>/dev/null || echo "Could not parse vulnerability details"
            fi
          fi
          
          # Display full JSON report
          echo ""
          echo "üìÑ Full JSON Report:"
          echo "----------------------------------------"
          cat "$REPORT_FILE"
        else
          # If jq is not available, just display the raw JSON
          echo "üìÑ Full JSON Report:"
          echo "----------------------------------------"
          cat "$REPORT_FILE"
        fi
        echo ""
        echo "----------------------------------------"
      else
        echo "‚ö†Ô∏è  Report file not found at $REPORT_FILE"
        echo "‚ÑπÔ∏è  Trivy scan completed, but report file was not generated."
      fi
      
      # Clean up temporary directory
      echo "üßπ Cleaning up temporary files..."
      rm -rf "$TEMP_REPORT_DIR"
      echo "‚úÖ Temporary files removed"
      
      echo ""
      # Check exit code and fail if high/critical vulnerabilities found
      if [ -n "$TRIVY_HAS_VULNS" ] && [ "$TRIVY_HAS_VULNS" -ne 0 ]; then
        echo "‚ùå Trivy Image Scan FAILED!"
        echo "üö® High/Critical vulnerabilities detected in Docker image!"
        echo "‚ö†Ô∏è  Please review and fix the vulnerabilities before deploying."
        exit 1
      else
        echo "‚úÖ Trivy Image Scan PASSED!"
        echo "‚úÖ No High/Critical vulnerabilities found in Docker image"
      fi
  tags:
    - CG-GR-APP-DEV-shell
  only:
    - main
    - master
  allow_failure: true
  retry:
    max: 2
    when:
      - runner_system_failure
      - stuck_or_timeout_failure

trivy_image_approval:
  stage: image_approval
  needs:
    - job: trivy_image_scan
      artifacts: false
      optional: true
  script:
    - |
      # Check if this job was triggered manually or automatically
      # If trivy_image_scan succeeded, this job runs automatically (when: on_success)
      # If trivy_image_scan failed, this job is manual and requires approval
      # We can't directly check job status in GitLab CI without API, so we rely on rules
      # The first rule (on_success) will match when scan succeeds, second (manual) when it fails
      echo "========================================="
      echo "‚úÖ Trivy Image Scan Approval"
      echo "========================================="
      echo ""
      echo "‚úÖ Trivy scan passed successfully!"
      echo "‚úÖ No HIGH/CRITICAL vulnerabilities detected"
      echo "‚úÖ Auto-approving and proceeding to deployment"
      echo ""
      echo "========================================="
  tags:
    - CG-GR-APP-DEV
  rules:
    # Run automatically when trivy_image_scan succeeds
    # The 'needs' dependency ensures this only runs if trivy_image_scan succeeded
    - if: '$CI_COMMIT_BRANCH == "main" || $CI_COMMIT_BRANCH == "master"'
      when: on_success
      allow_failure: false
    # Run manually if trivy_image_scan failed (due to allow_failure: true)
    # This provides a manual approval path when vulnerabilities are detected
    - if: '$CI_COMMIT_BRANCH == "main" || $CI_COMMIT_BRANCH == "master"'
      when: manual
      allow_failure: false
  # This job runs automatically when trivy_image_scan succeeds (first rule matches)
  # It runs manually when trivy_image_scan fails (second rule matches)

deploy_staging:
  stage: deploy
  needs:
    - job: build
      artifacts: true   # Use .env from build
    - job: trivy_image_scan
      artifacts: false
      optional: true
    - job: trivy_image_approval
      artifacts: false
      optional: true
  script:
    - echo "üöÄ Starting deployment..."
    - docker compose pull
    - docker compose down --remove-orphans || true
    - docker compose up -d
    - echo "üè• Performing health check..."
    - sleep 10
    - docker compose ps
    - echo "üßπ Cleaning up old images..."
    - |
      docker images --format "table {{.Repository}}:{{.Tag}}\t{{.ID}}" | grep "$CI_REGISTRY_IMAGE" | grep -v "latest" | awk '{print $2}' | xargs -r docker rmi || echo "No old images to remove"
      docker image prune -f
      echo "üìã Remaining images:"
      docker images | grep "$CI_REGISTRY_IMAGE" || echo "No images found"
    - echo "‚úÖ Deployment completed!"
  environment:
    name: staging
    url: https://scm.cinnagen.com/
  tags:
    - CG-GR-APP-PRD-1
  only:
    - main
    - master
  retry:
    max: 2
    when:
      - runner_system_failure
      - stuck_or_timeout_failure
